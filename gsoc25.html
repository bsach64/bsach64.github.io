<!DOCTYPE html>
<html lang="en">

<html>
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/iosevka/index.css">
		<script src="https://cdn.tailwindcss.com"></script>
		<script>
		tailwind.config = {
			theme: {
				extend: {
					colors: {
						'steelblue': '#4682B4',
						'coral': '#FF7F50',
					},
				},
				fontFamily: {
					mono: ['Iosevka', 'monospace'],
				},
			}
		}
		</script>
		<title>GSoC 2025 Work Report</title>
	</head>
	<body class="bg-black">
	<div class="flex justify-center items-center text-white min-h-screen pt-20 overflow-y-auto">
	<div class="flex flex-col justify-center items-start text-[#CCCCCC] max-w-5xl">
		<div class="flex justify-between flex-row w-full">
			<div class="flex flex-col justify-center">
				<div class="underline text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl">
				<a href="index.html" class="hover:text-coral">
					< home
				</a>
				</div>
			</div>
			<img class="h-[100px] w-[100px]" src="assets/bhavik.png">
		</div>
		<h1 class="text-steelblue font-mono text-4xl text-left m-4 font-bold">Support for Files on Unmounted Mounts: GSoC 2025</h1>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">What's CRIU?</h2>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			<b>CRIU</b> (Checkpoint/Restore in Userspace) allows you to freeze a running application and save it to disk (in the form of a set of image files).
			We can restore (or restart) the application using these image files.
			CRIU allows for container migration, snapshots, and the like. It is integrated into LXC, Docker, and Podman.
			<br>
		</div>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">The Project</h2>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			In order for CRIU to correctly checkpoint/restore a process (or container) it needs to dump all file descriptors the process has open and thus the mounts
			these fds are on. CRIU already does a pretty good job at doing so. However, if the file is on a mount that has been "unmounted" (<code>umount2(mnt, MNT_DETACH)</code>)
			we can't get information about the mount from  <code>/proc/$pid/mountinfo</code>. We want to divise a way to get mountinfo for such mounts and support checkpoint/restore for files on these mounts.
		</div>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Problems</h2>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			<ul class="list-disc pl-8 my-4">
				<li>
				Initially, I had the assumption that <a class="underline text-[#CCCCCC] hover:text-white" target="_blank" href="https://man7.org/linux/man-pages/man2/statmount.2.html"><code>statmount()</code></a> worked on
				"unmounted" mounts. This was incorrect. Thus, we had to come up with a way to export mountinfo for "unmounted" mounts using statmount().
				</li>
				<li>
				Even, if we had mountinfo, we would still have to figure out some way to checkpoint/restore the mount. Since, the mount has been "unmounted" we can't really get full information
				about the mount and files on that mount. So, we reduced the scope to add support for "unmounted" bind mounts, for now. This is simpler because we assume that the "unmounted" mount is a bind mount
				of a regular mount. Thus, we can just MNT_BIND from the regular mount during restore.
				</li>
			</ul>
		</div>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Linux Kernel Patches</h2>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
		We suggested two different approaches to export mountinfo for "unmounted" mounts using statmount():
		<ol class="list-decimal pl-8 my-4">
			<li>
			<b>A new mount namespace in the kernel for "unmounted" mounts</b>: If a mount gets "unmounted" it gets removed from all mount namespaces. We suggested instead they get added to a kernel only mount namespace.
			So, we can then call statmount() with this umount_mnt_ns namespace's mnt_ns_id to get the mountinfo we need. We also modified statx to export mnt_ns_id. Thus, to get mountinfo for a fd, we could do this:
			<br>
			<br>
			statx(fd, "", AT_EMPTY_PATH, MNT_ID_UNIQUE | MNT_NS_ID, &stat);
			<br>
			struct mnt_id_req req = { .size = MNT_ID_REQ_SIZE_VER1, .mnt_id = stat.mnt_id, .mnt_ns_id = stat.mnt_ns_id, .flags = /* flags */ };
			<br>
			statmount(&req, &statmount_buf, buf_size, 0);
			<br>
			<br>
			We sent our <a class="underline text-[#CCCCCC] hover:text-white" target="_blank" href="https://lore.kernel.org/all/20251002125422.203598-1-b.sachdev1904@gmail.com/">patch upstream</a>, but this approach has a
			few problems. It complicated the implementation of mount namespaces and mounts in the kernel (See the <a class="underline text-[#CCCCCC] hover:text-white" target="_blank" href="https://lore.kernel.org/all/20251002163427.GN39973@ZenIV/">discussion on the patchset</a>). We got feedback that the second approach was better.
			</li>
			<br>
			<li>
			<b>Adding a fd parameter to statmount():</b> We added a fd parameter to struct mnt_id_req and a new STATMOUNT_BY_FD flag to statmount(). This allowed statmount() to directly return mountinfo for the mount the fd is on,
			even if the fd is on an "unmounted" mount. Here's how it would work:
			<br>
			<br>
			struct mnt_id_req req = { .size = MNT_ID_REQ_SIZE_VER1, .fd = fd, .flags = /* flags */ };
			<br>
			statmount(&req, &statmount_buf, buf_size, STATMOUNT_BY_FD);
			<br>
			<br>
			The maintainers have mostly found this approach more acceptable.
			We have sent out two versions that implement fd-based-statmount()
			<a class="underline text-[#CCCCCC] hover:text-white" target="_blank" href="https://lore.kernel.org/linux-fsdevel/20251011124753.1820802-1-b.sachdev1904@gmail.com/">v2</a> and
			<a class="underline text-[#CCCCCC] hover:text-white" target="_blank" href="https://lore.kernel.org/linux-fsdevel/20251024181443.786363-1-b.sachdev1904@gmail.com/T/#u">v3</a>.
			We are in the process of incorporating their comments and hoping to upstream these changes soon.
			</li>
		</ol>
		</div>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">CRIU Changes</h2>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			Since, we focused on only supporting "unmounted" bind mounts, it made the CRIU changes relatively simpler. We did the following:
			<ol class="list-decimal pl-8 my-4">
				<li>Wrote a bunch of tests trying to cover all edge cases we could think of.</li>
				<li>Introduced the statmount() syscall in the CRIU codebase and added kerndat (system CRIU uses to check support for a kernel feature) checks for statmount().</li>
				<li>Added Ability to checkpoint/restore "unmounted" bind mounts.</li>
			</ol>
		</div>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Checkpoint/Restore of "unmounted" bind mounts</h2>
		<div class="text-coral text-bold font-mono text-2xl pl-[20px] pr-[20px] text-justify">Changes During Dump Stage</div><br>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			CRIU constructs a list of all mounts called mntinfo before it starts dumping fds. So, if during the dumping of fds, we get a mnt_id not in the mntinfo list,
			we assume it to be an "unmounted" mount. We then try to get mountinfo for this mount by using the statmount() syscall (with the changes we made) and mark this mount to be "unmounted" in the image.
		</div>
		<br>
		<div class="text-coral text-bold font-mono text-2xl pl-[20px] pr-[20px] text-justify">Changes During Restore Stage</div><br>
		<div class="text-[#CCCCCC] pl-[20px] pr-[20px] font-mono text-xl text-justify">
			Restoration of "unmounted" mounts takes place outside the general mount restore process.
			<ol class="list-decimal pl-8 my-4">
				<li>We create a list of detached_mounts during the collect phase.</li>
				<li>For each mount, we create a temporary mount point in the format: /.criu.detached.XXXXXX (since in case, of detached mounts we don't have a mountpoint)</li>
				<li>While opening fds, we open them at /.criu.detached.XXXXXX/$filename.</li>
				<li>After all files are restored we umount them using MNT_DETACH and remove all our mountpoints.</li>
			</ol>
		</div>
		<a class="text-coral text-bold font-mono text-2xl pl-[20px] pr-[20px] text-justify underline hover:text-white" target="_blank" href="https://github.com/checkpoint-restore/criu/pull/2754">Link to the CRIU Pull Request</a>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">What's Left To Do?</h2>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Learnings</h2>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Work After GSoC</h2>
		<h2 class="text-steelblue font-mono text-3xl text-left m-4 font-bold">Acknowledgements</h2>

	</div>
	</body>
</html>
